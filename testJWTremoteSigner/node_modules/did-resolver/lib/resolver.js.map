{"version":3,"file":"resolver.js","sources":["../src/resolver.ts"],"sourcesContent":["// Copyright 2018 Consensys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Extensible = Record<string, any>\n\nexport interface DIDResolutionResult {\n  '@context'?: 'https://w3id.org/did-resolution/v1' | string | string[]\n  didResolutionMetadata: DIDResolutionMetadata\n  didDocument: DIDDocument | null\n  didDocumentMetadata: DIDDocumentMetadata\n}\n\nexport interface DIDResolutionOptions extends Extensible {\n  accept?: string\n}\n\nexport interface DIDResolutionMetadata extends Extensible {\n  contentType?: string\n  error?: 'invalidDid' | 'notFound' | 'representationNotSupported' | 'unsupportedDidMethod' | string\n}\n\nexport interface DIDDocumentMetadata extends Extensible {\n  created?: string\n  updated?: string\n  deactivated?: boolean\n  versionId?: string\n  nextUpdate?: string\n  nextVersionId?: string\n  equivalentId?: string\n  canonicalId?: string\n}\n\nexport type KeyCapabilitySection =\n  | 'authentication'\n  | 'assertionMethod'\n  | 'keyAgreement'\n  | 'capabilityInvocation'\n  | 'capabilityDelegation'\n\nexport type DIDDocument = {\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | string[]\n  id: string\n  alsoKnownAs?: string[]\n  controller?: string | string[]\n  verificationMethod?: VerificationMethod[]\n  service?: ServiceEndpoint[]\n  /**\n   * @deprecated\n   */\n  publicKey?: VerificationMethod[]\n} & {\n  [x in KeyCapabilitySection]?: (string | VerificationMethod)[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\n/**\n * Encapsulates a JSON web key type that includes only the public properties that\n * can be used in DID documents.\n *\n * The private properties are intentionally omitted to discourage the use\n * (and accidental disclosure) of private keys in DID documents.\n */\nexport interface JsonWebKey extends Extensible {\n  alg?: string\n  crv?: string\n  e?: string\n  ext?: boolean\n  key_ops?: string[]\n  kid?: string\n  kty: string\n  n?: string\n  use?: string\n  x?: string\n  y?: string\n}\n\nexport interface VerificationMethod {\n  id: string\n  type: string\n  controller: string\n  publicKeyBase58?: string\n  publicKeyBase64?: string\n  publicKeyJwk?: JsonWebKey\n  publicKeyHex?: string\n  publicKeyMultibase?: string\n  blockchainAccountId?: string\n  ethereumAddress?: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolvable,\n  options: DIDResolutionOptions\n) => Promise<DIDResolutionResult>\nexport type WrappedResolver = () => Promise<DIDResolutionResult>\nexport type DIDCache = (parsed: ParsedDID, resolve: WrappedResolver) => Promise<DIDResolutionResult>\nexport type LegacyDIDResolver = (did: string, parsed: ParsedDID, resolver: Resolvable) => Promise<DIDDocument>\n\nexport type ResolverRegistry = Record<string, DIDResolver>\n\nexport interface LegacyResolverRegistry {\n  [index: string]: LegacyDIDResolver\n}\n\nexport interface ResolverOptions {\n  cache?: DIDCache | boolean | undefined\n  legacyResolvers?: LegacyResolverRegistry\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDResolutionResult> = new Map()\n  return async (parsed: ParsedDID, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true') return await resolve()\n\n    const cached = cache.get(parsed.didUrl)\n    if (cached !== undefined) return cached\n    const result = await resolve()\n    if (result.didResolutionMetadata?.error !== 'notFound') {\n      cache.set(parsed.didUrl, result)\n    }\n    return result\n  }\n}\n\nexport function noCache(parsed: ParsedDID, resolve: WrappedResolver): Promise<DIDResolutionResult> {\n  return resolve()\n}\n\nconst PCT_ENCODED = '(?:%[0-9a-fA-F]{2})'\nconst ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`\nconst METHOD = '([a-z0-9]+)'\nconst METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(#.*)?`\nconst DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`)\n\nexport function parse(didUrl: string): ParsedDID | null {\n  if (didUrl === '' || !didUrl) return null\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl,\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  return null\n}\n\nconst EMPTY_RESULT: DIDResolutionResult = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {},\n}\n\nexport function wrapLegacyResolver(resolve: LegacyDIDResolver): DIDResolver {\n  return async (did, parsed, resolver) => {\n    try {\n      const doc = await resolve(did, parsed, resolver)\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument: doc,\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString(), // This is not in spec, but may be helpful\n        },\n      }\n    }\n  }\n}\n\nexport interface Resolvable {\n  resolve: (didUrl: string, options?: DIDResolutionOptions) => Promise<DIDResolutionResult>\n}\n\nexport class Resolver implements Resolvable {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(registry: ResolverRegistry = {}, options: ResolverOptions = {}) {\n    this.registry = registry\n    this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache\n    if (options.legacyResolvers) {\n      Object.keys(options.legacyResolvers).map((methodName) => {\n        if (!this.registry[methodName]) {\n          this.registry[methodName] = wrapLegacyResolver(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            options.legacyResolvers![methodName]\n          )\n        }\n      })\n    }\n  }\n\n  async resolve(didUrl: string, options: DIDResolutionOptions = {}): Promise<DIDResolutionResult> {\n    const parsed = parse(didUrl)\n    if (parsed === null) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' },\n      }\n    }\n    const resolver = this.registry[parsed.method]\n    if (!resolver) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'unsupportedDidMethod' },\n      }\n    }\n    return this.cache(parsed, () => resolver(parsed.did, parsed, this, options))\n  }\n}\n"],"names":["inMemoryCache","cache","Map","parsed","resolve","cached","get","didUrl","undefined","result","didResolutionMetadata","error","set","params","noCache","PCT_ENCODED","ID_CHAR","METHOD","METHOD_ID","PARAM_CHAR","PARAM","PARAMS","PATH","QUERY","FRAGMENT","DID_MATCHER","RegExp","parse","sections","match","parts","did","method","id","slice","split","p","kv","path","query","fragment","EMPTY_RESULT","didDocument","didDocumentMetadata","wrapLegacyResolver","resolver","doc","contentType","e","message","toString","Resolver","constructor","registry","options","legacyResolvers","Object","keys","map","methodName"],"mappings":"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"}